<!doctype html>
<html lang="en">
<head>
  <title>lol</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <link href="bundle.css" rel="stylesheet">
</head>
<body>
  <script id="fragmentShaderOctree" type="x-shader/x-fragment">
    uniform float sqrRoot;
    const float EPS = 0.0001;
    const float gravity = -1.;
    const float theta = 0.8;
    #ITERATIONS_CONST

    void main() {
      vec2 uv = gl_FragCoord.xy / resolution.xy;
      vec2 nextPixel = vec2(gl_FragCoord.x + 1.0, gl_FragCoord.y) / resolution.xy;
      int debugCompletedIterations = 0;

      if(nextPixel.x + 1.0 >= sqrRoot) {
        nextPixel = vec2(0.0, uv.y + 1.0);
      }

      vec4 sourceBodyPos = texture2D( textureOctree, uv );

      if(abs(texture2D(textureOctree, nextPixel).w - 0.5) > EPS) {
        discard;
      } else {
        float fx = 0.;
        float fy = 0.;
        float fz = 0.;
        float v = 0.;
        float r = 0.;
        float dx = 0.;
        float dy = 0.;
        float dz = 0.;
        float mass;
        float pixelIndex;
        int debugInt = 27;
        float debugVal = 27.;
        float queue[iterations];
        int queueLength = 1;
        float sourceBodyMass = texture2D( textureOctree, nextPixel ).x;
        int pushIdx = 1;

        queue[0] = 0.;

        for(int i=0; i<iterations; i++) {
          if(queueLength < 1) { 
            break; 
          }

          debugCompletedIterations++;

          pixelIndex = queue[i] / 4.;
          vec2 nodeIndices[10];
          nodeIndices[0] = vec2(mod(pixelIndex, sqrRoot) / sqrRoot, floor(pixelIndex / sqrRoot) / sqrRoot);
          nodeIndices[1] = vec2(mod(pixelIndex + 1., sqrRoot) / sqrRoot, floor((pixelIndex + 1.) / sqrRoot) / sqrRoot);
          nodeIndices[2] = vec2(mod(pixelIndex + 2., sqrRoot) / sqrRoot, floor((pixelIndex + 2.) / sqrRoot) / sqrRoot);
          nodeIndices[3] = vec2(mod(pixelIndex + 3., sqrRoot) / sqrRoot, floor((pixelIndex + 3.) / sqrRoot) / sqrRoot);
          nodeIndices[4] = vec2(mod(pixelIndex + 4., sqrRoot) / sqrRoot, floor((pixelIndex + 4.) / sqrRoot) / sqrRoot);
          nodeIndices[5] = vec2(mod(pixelIndex + 5., sqrRoot) / sqrRoot, floor((pixelIndex + 5.) / sqrRoot) / sqrRoot);
          nodeIndices[6] = vec2(mod(pixelIndex + 6., sqrRoot) / sqrRoot, floor((pixelIndex + 6.) / sqrRoot) / sqrRoot);
          nodeIndices[7] = vec2(mod(pixelIndex + 7., sqrRoot) / sqrRoot, floor((pixelIndex + 7.) / sqrRoot) / sqrRoot);
          nodeIndices[8] = vec2(mod(pixelIndex + 8., sqrRoot) / sqrRoot, floor((pixelIndex + 8.) / sqrRoot) / sqrRoot);
          nodeIndices[9] = vec2(mod(pixelIndex + 9., sqrRoot) / sqrRoot, floor((pixelIndex + 9.) / sqrRoot) / sqrRoot);

          vec4 textureReads[10];
          textureReads[0] = texture2D( textureOctree, nodeIndices[0] );
          textureReads[1] = texture2D( textureOctree, nodeIndices[1] );

          vec4 body = textureReads[0];
          bool isLeaf = abs(0.5 - textureReads[1].w) < EPS;
          bool differentBody = true;
          mass = textureReads[1].x;

          queueLength -= 1;

          if(isLeaf) {
            differentBody = !(abs(body.x - sourceBodyPos.x) < EPS && abs(body.y - sourceBodyPos.y) < EPS && abs(body.z - sourceBodyPos.z) < EPS);
          }

          if(isLeaf && differentBody) {
            dx = body.x - sourceBodyPos.x;
            dy = body.y - sourceBodyPos.y;
            dz = body.z - sourceBodyPos.z;
            r = sqrt(dx * dx + dy * dy + dz * dz);

            if(r < EPS) {
              r = EPS;
            }

            v = gravity * mass * sourceBodyMass / (r * r * r);
            fx += v * dx;
            fy += v * dy;
            fz += v * dz;
          } else if(differentBody) {
            dx = body.x / mass - sourceBodyPos.x;
            dy = body.y / mass - sourceBodyPos.y;
            dz = body.z / mass - sourceBodyPos.z;

            r = sqrt(dx * dx + dy * dy + dz * dz);

            if(r < EPS) {
              r = EPS;
            }

            if((body.w / r < theta) || (i == iterations - 1)) {
              v = gravity * mass * sourceBodyMass / (r * r * r);
              fx += v * dx;
              fy += v * dy;
              fz += v * dz;
            } else {
              if(texture2D(textureOctree, nodeIndices[2]).w > EPS) {
                #CHILD_2
                pushIdx++;
                queueLength++;
              }
              if(texture2D(textureOctree, nodeIndices[3]).w > EPS) {
                #CHILD_3
                pushIdx++;
                queueLength++;
              }
              if(texture2D(textureOctree, nodeIndices[4]).w > EPS) {
                #CHILD_4
                pushIdx++;
                queueLength++;
              }
              if(texture2D(textureOctree, nodeIndices[5]).w > EPS) {
                #CHILD_5
                pushIdx++;
                queueLength++;
              }
              if(texture2D(textureOctree, nodeIndices[6]).w > EPS) {
                #CHILD_6
                pushIdx++;
                queueLength++;
              }
              if(texture2D(textureOctree, nodeIndices[7]).w > EPS) {
                #CHILD_7
                pushIdx++;
                queueLength++;
              }
              if(texture2D(textureOctree, nodeIndices[8]).w > EPS) {
                #CHILD_8
                pushIdx++;
                queueLength++;
              }
              if(texture2D(textureOctree, nodeIndices[9]).w > EPS) {
                #CHILD_9
                pushIdx++;
                queueLength++;
              }
            }
          }

          // if(debugCompletedIterations == 54 && sourceBodyPos[0] - 9. < EPS && sourceBodyPos[1] + 6. < EPS && sourceBodyPos[2] - 3. < EPS) {
          //   debugVal = fz;
          // }
        }

        gl_FragColor = vec4(fx, fy, fz, 0);
      }
    }
  </script>
  <script type="x-shader/x-vertex" id="node-vertex-shader">
    uniform float cameraDistance;
    attribute vec4 color;
    varying vec4 vColor;

    void main() {
      vColor = color;
      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * mvPosition;
      gl_PointSize = 10.0 * ( cameraDistance / -mvPosition.z );
    }
  </script>
  <script type="x-shader/x-fragment" id="node-fragment-shader">
    uniform sampler2D tex;
    varying vec4 vColor;

    void main() {
      vec4 textureColor = texture2D(tex, gl_PointCoord);
      gl_FragColor = vColor * textureColor;
    }
  </script>
  <script type="x-shader/x-vertex" id="edge-vertex-shader">
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  </script>
  <script type="x-shader/x-fragment" id="edge-fragment-shader">
    void main() {
      gl_FragColor = vec4(1.0, 1.0, 1.0, 0.1);
    }
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js"></script>
  <script src="/dist/main.js"></script>
</body>
</html>
