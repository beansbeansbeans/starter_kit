/**
 * This is Barnes Hut simulation algorithm for 3d case. Implementation
 * is highly optimized (avoids recusion and gc pressure)
 *
 * http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html
 */

var gpuComputationRenderer = require('./gpucomputationrenderer'),
  texturifyOctree = require('./texturifyOctree'),
  flattenedTree = [],
  pixelsPerNode = 10  // 1 for center of mass (or position if leaf), 1 for mass and status, 8 for children

module.exports = function(options) {
  options = options || {};
  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;
  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;

  // we require deterministic randomness here
  var random = require('ngraph.random').random(1984),
    Node = require('./node'),
    InsertStack = require('./insertStack'),
    isSamePosition = require('./isSamePosition');

  var gravity = options.gravity,
    updateQueue = [],
    insertStack = new InsertStack(),
    theta = options.theta,
    depth = 1,

    nodesCache = [],
    currentInCache = 0,
    newNode = function(nodeDepth, parentIndex, quadrant) {
      // To avoid pressure on GC we reuse nodes.
      var node = nodesCache[currentInCache];
      if (node) {
        node.depth = nodeDepth
        node.quad0 = null;
        node.quad4 = null;
        node.quad1 = null;
        node.quad5 = null;
        node.quad2 = null;
        node.quad6 = null;
        node.quad3 = null;
        node.quad7 = null;
        node.body = null;
        node.mass = node.massX = node.massY = node.massZ = 0;
        node.left = node.right = node.top = node.bottom = node.front = node.back = 0;
      } else {
        node = new Node(nodeDepth);
        nodesCache[currentInCache] = node;
      }

      ++currentInCache;
      
      node.flattenedTreeIndex = flattenedTree.length
      for(var i=0; i<pixelsPerNode; i++) {
        for(var j=0; j<4; j++) {
          flattenedTree.push(0)
        }
      }

      if(parentIndex) {
        for(var j=0; j<4; j++) {
          var val = 0
          if(j === 0) {
            val = node.flattenedTreeIndex
          } else if(j === 3) {
            val = 1
          }

          flattenedTree[parentIndex + 8 + (quadrant * 4) + j] = val
        }
      }
      return node;
    },

    root = newNode(0),

    // Inserts body to the tree
    insert = function(newBody) {
      insertStack.reset();
      insertStack.push(root, newBody);

      while (!insertStack.isEmpty()) {
        var stackItem = insertStack.pop(),
          node = stackItem.node,
          body = stackItem.body;

        if (!node.body) {
          // This is internal node. Update the total mass of the node and center-of-mass.
          var x = body.pos.x;
          var y = body.pos.y;
          var z = body.pos.z;
          node.mass += body.mass;
          node.massX += body.mass * x;
          node.massY += body.mass * y;
          node.massZ += body.mass * z;

          flattenedTree[node.flattenedTreeIndex] = node.massX
          flattenedTree[node.flattenedTreeIndex + 1] = node.massY
          flattenedTree[node.flattenedTreeIndex + 2] = node.massZ
          flattenedTree[node.flattenedTreeIndex + 3] = node.right - node.left

          flattenedTree[node.flattenedTreeIndex + 4] = node.mass
          flattenedTree[node.flattenedTreeIndex + 5] = 0
          flattenedTree[node.flattenedTreeIndex + 6] = 0
          flattenedTree[node.flattenedTreeIndex + 7] = 1

          // Recursively insert the body in the appropriate quadrant.
          // But first find the appropriate quadrant.
          var quadIdx = 0, // Assume we are in the 0's quad.
            left = node.left,
            right = (node.right + left) / 2,
            top = node.top,
            bottom = (node.bottom + top) / 2,
            back = node.back,
            front = (node.front + back) / 2;

          if (x > right) { // somewhere in the eastern part.
            quadIdx += 1;
            var oldLeft = left;
            left = right;
            right = right + (right - oldLeft);
          }
          if (y > bottom) { // and in south.
            quadIdx += 2;
            var oldTop = top;
            top = bottom;
            bottom = bottom + (bottom - oldTop);
          }
          if (z > front) { // and in frontal part
            quadIdx += 4;
            var oldBack = back;
            back = front;
            front = back + (back - oldBack);
          }

          var child = getChild(node, quadIdx);
          if (!child) {
            // The node is internal but this quadrant is not taken. Add subnode to it.
            child = newNode(node.depth + 1, node.flattenedTreeIndex, quadIdx);
            child.left = left;
            child.top = top;
            child.right = right;
            child.bottom = bottom;
            child.back = back;
            child.front = front;
            child.body = body;
            // so we can access octreeTexture coordinates from the child body
            child.body.flattenedTreeIndex = child.flattenedTreeIndex

            flattenedTree[child.flattenedTreeIndex] = body.pos.x
            flattenedTree[child.flattenedTreeIndex + 1] = body.pos.y
            flattenedTree[child.flattenedTreeIndex + 2] = body.pos.z
            flattenedTree[child.flattenedTreeIndex + 3] = right - left
            flattenedTree[child.flattenedTreeIndex + 4] = body.mass
            flattenedTree[child.flattenedTreeIndex + 5] = 0
            flattenedTree[child.flattenedTreeIndex + 6] = 0
            flattenedTree[child.flattenedTreeIndex + 7] = 0.5 // signify leaf status

            depth = Math.max(depth, child.depth)

            setChild(node, quadIdx, child);
          } else {
            // continue searching in this quadrant.
            insertStack.push(child, body);
          }
        } else {
          // We are trying to add to the leaf node.
          // We have to convert current leaf into internal node
          // and continue adding two nodes.
          var oldBody = node.body;
          node.body = null; // internal nodes do not carry bodies

          if (isSamePosition(oldBody.pos, body.pos)) {
            // Prevent infinite subdivision by bumping one node
            // anywhere in this quadrant
            var retriesCount = 3;
            do {
              var offset = random.nextDouble();
              var dx = (node.right - node.left) * offset;
              var dy = (node.bottom - node.top) * offset;
              var dz = (node.front - node.back) * offset;

              oldBody.pos.x = node.left + dx;
              oldBody.pos.y = node.top + dy;
              oldBody.pos.z = node.back + dz;
              retriesCount -= 1;
              // Make sure we don't bump it out of the box. If we do, next iteration should fix it
            } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));

            if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {
              // This is very bad, we ran out of precision.
              // if we do not return from the method we'll get into
              // infinite loop here. So we sacrifice correctness of layout, and keep the app running
              // Next layout iteration should get larger bounding box in the first step and fix this
              return;
            }
          }
          // Next iteration should subdivide node further.
          insertStack.push(node, oldBody);
          insertStack.push(node, body);
        }
      }
    },

    update = function(sourceBody, index, nodeIndex) {
      var force = texturifyOctree.update(sourceBody, index, nodeIndex)

      sourceBody.force.x += force[0];
      sourceBody.force.y += force[1];
      sourceBody.force.z += force[2];
    },

    insertBodies = function(bodies) {
      var x1 = Number.MAX_VALUE,
        y1 = Number.MAX_VALUE,
        z1 = Number.MAX_VALUE,
        x2 = Number.MIN_VALUE,
        y2 = Number.MIN_VALUE,
        z2 = Number.MIN_VALUE,
        i,
        max = bodies.length;

      flattenedTree = []

      // To reduce quad tree depth we are looking for exact bounding box of all particles.
      i = max;
      while (i--) {
        var pos = bodies[i].pos;
        var x = pos.x;
        var y = pos.y;
        var z = pos.z;
        if (x < x1) {
          x1 = x;
        }
        if (x > x2) {
          x2 = x;
        }
        if (y < y1) {
          y1 = y;
        }
        if (y > y2) {
          y2 = y;
        }
        if (z < z1) {
          z1 = z;
        }
        if (z > z2) {
          z2 = z;
        }
      }

      // Squarify the bounds.
      var maxSide = Math.max(x2 - x1, Math.max(y2 - y1, z2 - z1));

      x2 = x1 + maxSide;
      y2 = y1 + maxSide;
      z2 = z1 + maxSide;

      currentInCache = 0;
      root = newNode(0);
      root.left = x1;
      root.right = x2;
      root.top = y1;
      root.bottom = y2;
      root.back = z1;
      root.front = z2;

      flattenedTree[0] = 0
      flattenedTree[1] = 0
      flattenedTree[2] = 0
      flattenedTree[3] = x2 - x1

      i = max - 1;
      if (i > 0) {
        root.body = bodies[i];
      }
      while (i--) {
        insert(bodies[i], root);
      }

      texturifyOctree.initialize(flattenedTree)
      texturifyOctree.texturify(flattenedTree)
    };

  return {
    insertBodies: insertBodies,
    updateBodyForce: update,
    options: function(newOptions) {
      if (newOptions) {
        if (typeof newOptions.gravity === 'number') {
          gravity = newOptions.gravity;
        }
        if (typeof newOptions.theta === 'number') {
          theta = newOptions.theta;
        }

        return this;
      }

      return {
        gravity: gravity,
        theta: theta
      };
    }
  };
};

function getChild(node, idx) {
  if (idx === 0) return node.quad0;
  if (idx === 1) return node.quad1;
  if (idx === 2) return node.quad2;
  if (idx === 3) return node.quad3;
  if (idx === 4) return node.quad4;
  if (idx === 5) return node.quad5;
  if (idx === 6) return node.quad6;
  if (idx === 7) return node.quad7;
  return null;
}

function setChild(node, idx, child) {
  if (idx === 0) node.quad0 = child;
  else if (idx === 1) node.quad1 = child;
  else if (idx === 2) node.quad2 = child;
  else if (idx === 3) node.quad3 = child;
  else if (idx === 4) node.quad4 = child;
  else if (idx === 5) node.quad5 = child;
  else if (idx === 6) node.quad6 = child;
  else if (idx === 7) node.quad7 = child;

  flattenedTree[node.flattenedTreeIndex + 8 + (idx * 4)] = child.flattenedTreeIndex
  flattenedTree[node.flattenedTreeIndex + 8 + (idx * 4) + 1] = 0
  flattenedTree[node.flattenedTreeIndex + 8 + (idx * 4) + 2] = 0
  flattenedTree[node.flattenedTreeIndex + 8 + (idx * 4) + 3] = 1
}
