var textureData, 
  EPS = 0.0001,
  output = [],
  sqrRoot = 0,
  random = require('ngraph.random').random(1984),
  theta = 0.8,
  gravity = -1

function nearestPow2( aSize ) {
  return Math.pow( 2, Math.ceil( Math.log( aSize ) / Math.log( 2 ) ) ); 
}

var renderer = new THREE.WebGLRenderer(),
  scene = new THREE.Scene,
  camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 )

module.exports = {
  texturify: function(data) {
    sqrRoot = nearestPow2(Math.ceil(Math.sqrt(data.length / 4)))

    var desiredLength = sqrRoot * sqrRoot * 4 // is this needed?

    for(var i=data.length; i<desiredLength; i++) {
      data.push(0)
    }

    textureData = Float32Array.from(data)
    var positions = new THREE.DataTexture( textureData, sqrRoot, sqrRoot, THREE.RGBAFormat, THREE.FloatType )
    positions.needsUpdate = true

    var gpuCompute = new GPUComputationRenderer(sqrRoot, sqrRoot, renderer)

    var treeVariable = gpuCompute.addVariable("textureOctree", document.getElementById("fragmentShaderOctree").textContent, positions)

    gpuCompute.setVariableDependencies(treeVariable, [ treeVariable ])
    treeUniforms = treeVariable.material.uniforms
    treeUniforms.sqrRoot = { value: sqrRoot }
    treeVariable.wrapS = THREE.RepeatWrapping
    treeVariable.wrapT = THREE.RepeatWrapping

    renderer.render(scene, camera)

    gpuCompute.init()
    gpuCompute.compute()

    var textureValue = gpuCompute.getCurrentRenderTarget(treeVariable).texture

    var gl = renderer.getContext()
    output = new Float32Array(desiredLength)
    gl.readPixels(0, 0, sqrRoot, sqrRoot, gl.RGBA, gl.FLOAT, output);
  },
  update: function(sourceBody) { // this needs to run on the GPU someday
    return [output[sourceBody.flattenedTreeIndex],
      output[sourceBody.flattenedTreeIndex + 1],
      output[sourceBody.flattenedTreeIndex + 2]]
  }
}