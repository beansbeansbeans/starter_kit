var textureData, 
  getTreeAccessShader = require('./getTreeAccessShader'),
  getMaxIterations = require('./getMaxIterations'),
  output = [],
  sqrRoot = 0,
  desiredLength

function nearestPow2( aSize ) {
  return Math.pow( 2, Math.ceil( Math.log( aSize ) / Math.log( 2 ) ) ); 
}

var renderer = new THREE.WebGLRenderer(),
  gl = renderer.getContext(),
  treeAccessShader,
  initialized = false

module.exports = {
  initialize: function(data) {
    if(initialized) return

    sqrRoot = nearestPow2(Math.ceil(Math.sqrt(data.length / 4)))
    desiredLength = sqrRoot * sqrRoot * 4

    for(var i=data.length; i<desiredLength; i++) {
      data.push(0)
    }

    var maxIterations = getMaxIterations(data, sqrRoot)
    treeAccessShader = getTreeAccessShader(maxIterations)

    output = new Float32Array(desiredLength)
    
    initialized = true
  },
  texturify: function(data) {
    for(var i=data.length; i<desiredLength; i++) {
      data.push(0)
    }

    textureData = Float32Array.from(data)

    var positions = new THREE.DataTexture( textureData, sqrRoot, sqrRoot, THREE.RGBAFormat, THREE.FloatType )
    positions.needsUpdate = true

    var gpuCompute = new GPUComputationRenderer(sqrRoot, sqrRoot, renderer)

    var treeVariable = gpuCompute.addVariable("textureOctree", treeAccessShader, positions)

    gpuCompute.setVariableDependencies(treeVariable, [ treeVariable ])
    treeUniforms = treeVariable.material.uniforms
    treeUniforms.sqrRoot = { value: sqrRoot }
    treeVariable.wrapS = THREE.RepeatWrapping
    treeVariable.wrapT = THREE.RepeatWrapping

    gpuCompute.init()
    gpuCompute.compute()
    
    gl.readPixels(0, 0, sqrRoot, sqrRoot, gl.RGBA, gl.FLOAT, output);
  },
  update: function(sourceBody, iterationIndex, nodeIndex) {
    return [output[sourceBody.flattenedTreeIndex],
      output[sourceBody.flattenedTreeIndex + 1],
      output[sourceBody.flattenedTreeIndex + 2]]
  }
}