var pretendImageData = [], outputTexture = [], unrolledOutputTexture = [],
  EPS = 0.0001,
  random = require('ngraph.random').random(1984),
  theta = 0.8,
  gravity = -1

function texture2D(coordinates) {
  return pretendImageData[coordinates[0]][coordinates[1]]
}

module.exports = function(textureData, sqrRoot) {
  pretendImageData = []
  outputTexture = []
  unrolledOutputTexture = []

  var maxIterations = 0

  for(var i=0; i<sqrRoot; i++) {
    outputTexture.push([])
    pretendImageData.push([])
  }

  for(var i=0; i<sqrRoot; i++) {
    for(var j=0; j<sqrRoot; j++) {
      outputTexture[j].push([0, 0, 0, 0])
      pretendImageData[j].push([
        textureData[i * (4 * sqrRoot) + j * 4],
        textureData[i * (4 * sqrRoot) + j * 4 + 1],
        textureData[i * (4 * sqrRoot) + j * 4 + 2],
        textureData[i * (4 * sqrRoot) + j * 4 + 3]
      ])
    }
  }

  for(var i=0; i<sqrRoot; i++) {
    for(var j=0; j<sqrRoot; j++) {
      var uv = [j, i], // [x, y]
        nextPixel = [j + 1, i]

      if(j + 1 >= sqrRoot) {
        nextPixel = [0, i + 1]
      }

      if(typeof texture2D(nextPixel) === 'undefined' || Math.abs(0.5 - texture2D(nextPixel)[3]) > EPS) { // is internal node or empty node
        continue
      }

      var queue = [],
        queueLength = 1,
        shiftIdx = 0,
        pushIdx = 1,
        fx = 0, fy = 0, fz = 0,
        v, r,
        dx, dy, dz,
        sourceBodyPos = texture2D(uv),
        sourceBodyMass = texture2D(nextPixel)[0],
        iterations = 0

      queue[0] = 0

      while(queueLength) {
        iterations++
        maxIterations = Math.max(maxIterations, iterations)
        var pixelIndex = queue[shiftIdx] / 4,
          nodeIndices = [
            [pixelIndex % sqrRoot, Math.floor(pixelIndex / sqrRoot)],
            [(pixelIndex + 1) % sqrRoot, Math.floor((pixelIndex + 1) / sqrRoot)],
            [(pixelIndex + 2) % sqrRoot, Math.floor((pixelIndex + 2) / sqrRoot)],
            [(pixelIndex + 3) % sqrRoot, Math.floor((pixelIndex + 3) / sqrRoot)],
            [(pixelIndex + 4) % sqrRoot, Math.floor((pixelIndex + 4) / sqrRoot)],
            [(pixelIndex + 5) % sqrRoot, Math.floor((pixelIndex + 5) / sqrRoot)],
            [(pixelIndex + 6) % sqrRoot, Math.floor((pixelIndex + 6) / sqrRoot)],
            [(pixelIndex + 7) % sqrRoot, Math.floor((pixelIndex + 7) / sqrRoot)],
            [(pixelIndex + 8) % sqrRoot, Math.floor((pixelIndex + 8) / sqrRoot)],
            [(pixelIndex + 9) % sqrRoot, Math.floor((pixelIndex + 9) / sqrRoot)]
          ],
          body = texture2D(nodeIndices[0]),
          isLeaf = Math.abs(0.5 - texture2D(nodeIndices[1])[3]) < EPS,
          differentBody = true,
          mass = texture2D(nodeIndices[1])[0]

        queueLength -= 1
        shiftIdx += 1

        if(isLeaf) { // is a leaf
          differentBody = !(
            Math.abs(body[0] - sourceBodyPos[0]) < EPS &&
            Math.abs(body[1] - sourceBodyPos[1]) < EPS &&
            Math.abs(body[2] - sourceBodyPos[2]) < EPS)
        }

        if(isLeaf && differentBody) { // done
          dx = body[0] - sourceBodyPos[0]
          dy = body[1] - sourceBodyPos[1]
          dz = body[2] - sourceBodyPos[2]
          r = Math.sqrt(dx * dx + dy * dy + dz * dz)

          if (r === 0) {
            dx = (random.nextDouble() - 0.5) / 50
            dy = (random.nextDouble() - 0.5) / 50
            dz = (random.nextDouble() - 0.5) / 50
            r = Math.sqrt(dx * dx + dy * dy + dz * dz)
          }

          v = gravity * mass * sourceBodyMass / (r * r * r)
          fx += v * dx
          fy += v * dy
          fz += v * dz
        } else if(differentBody) {
          dx = body[0] / mass - sourceBodyPos[0]
          dy = body[1] / mass - sourceBodyPos[1]
          dz = body[2] / mass - sourceBodyPos[2]

          r = Math.sqrt(dx * dx + dy * dy + dz * dz)

          if (r === 0) {
            dx = (random.nextDouble() - 0.5) / 50
            dy = (random.nextDouble() - 0.5) / 50
            dz = (random.nextDouble() - 0.5) / 50
            r = Math.sqrt(dx * dx + dy * dy + dz * dz)
          }

          if((body[3]) / r < theta) { // done
            v = gravity * mass * sourceBodyMass / (r * r * r)
            fx += v * dx
            fy += v * dy
            fz += v * dz
          } else {
            if(texture2D(nodeIndices[2])[3]) { // if not zero
              queue[pushIdx] = texture2D(nodeIndices[2])[0]
              queueLength += 1;
              pushIdx += 1;
            }
            if (texture2D(nodeIndices[3])[3]) {
              queue[pushIdx] = texture2D(nodeIndices[3])[0];
              queueLength += 1;
              pushIdx += 1;
            }
            if (texture2D(nodeIndices[4])[3]) {
              queue[pushIdx] = texture2D(nodeIndices[4])[0];
              queueLength += 1;
              pushIdx += 1;
            }
            if (texture2D(nodeIndices[5])[3]) {
              queue[pushIdx] = texture2D(nodeIndices[5])[0];
              queueLength += 1;
              pushIdx += 1;
            }
            if (texture2D(nodeIndices[6])[3]) {
              queue[pushIdx] = texture2D(nodeIndices[6])[0];
              queueLength += 1;
              pushIdx += 1;
            }
            if (texture2D(nodeIndices[7])[3]) {
              queue[pushIdx] = texture2D(nodeIndices[7])[0];
              queueLength += 1;
              pushIdx += 1;
            }
            if (texture2D(nodeIndices[8])[3]) {
              queue[pushIdx] = texture2D(nodeIndices[8])[0];
              queueLength += 1;
              pushIdx += 1;
            }
            if (texture2D(nodeIndices[9])[3]) {
              queue[pushIdx] = texture2D(nodeIndices[9])[0];
              queueLength += 1;
              pushIdx += 1;
            }
          }
        }
        // the first point traversed by texture
        if(Math.abs(sourceBodyPos[0] - 9) < 0.01 &&
          Math.abs(sourceBodyPos[1] + 6) < 0.01 &&
          Math.abs(sourceBodyPos[2] - 3) < 0.01) {
          // debugger;
        }
      }
      outputTexture[j][i] = [fx, fy, fz, 0]
    }
  }

  for(var i=0; i<sqrRoot; i++) {
    for(var j=0; j<sqrRoot; j++) {
      for(var k=0; k<4; k++) {
        unrolledOutputTexture.push(outputTexture[j][i][k])
      }
    }
  }

  return maxIterations
}