/**
 * Performs 3d forces integration, using given timestep. Uses Euler method to solve
 * differential equation (http://en.wikipedia.org/wiki/Euler_method ).
 *
 * @returns {Number} squared distance of total position updates.
 */

module.exports = integrate;

function integrate(bodies, timeStep, buffer, stable) {
  var dx = 0, tx = 0,
      dy = 0, ty = 0,
      dz = 0, tz = 0,
      i,
      max = bodies.length;

  for (i = 0; i < max; ++i) {
    var body = bodies[i],
        coeff = timeStep / body.mass;

    if(stable) {
      if(body.velocity.x > 0) {
        body.velocity.x *= body.velocity.x
      } else {
        body.velocity.x *= -body.velocity.x
      }
      if(body.velocity.y > 0) {
        body.velocity.y *= body.velocity.y
      } else {
        body.velocity.y *= -body.velocity.y
      }
      if(body.velocity.z > 0) {
        body.velocity.z *= body.velocity.z
      } else {
        body.velocity.z *= -body.velocity.z
      }
    } else {
      body.velocity.x += coeff * body.force.x;
      body.velocity.y += coeff * body.force.y;
      body.velocity.z += coeff * body.force.z;      
    }

    var vx = body.velocity.x,
        vy = body.velocity.y,
        vz = body.velocity.z,
        v = Math.sqrt(vx * vx + vy * vy + vz * vz);

    if (v > 1) {
      body.velocity.x = vx / v;
      body.velocity.y = vy / v;
      body.velocity.z = vz / v;
    }

    dx = timeStep * body.velocity.x;
    dy = timeStep * body.velocity.y;
    dz = timeStep * body.velocity.z;

    body.pos.x += (dx + buffer.x);
    body.pos.y += (dy + buffer.y);
    body.pos.z += (dz + buffer.z);

    tx += Math.abs(dx); ty += Math.abs(dy); tz += Math.abs(dz);
  }

  return (tx * tx + ty * ty + tz * tz)/bodies.length;
}
